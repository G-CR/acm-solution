[题目链接](https://ac.nowcoder.com/acm/problem/13249)

题意：n个节点的树，每个节点都有一个向上染色的能力k，k为1就给自己染色，k为2就可以给一个父节点染色以此类推，问选最少几个节点可以把本来是白色的树给染黑。

思路：之前在[CF](https://codeforces.com/contest/892/problem/B)上做的一个题目的简单版本，可以先看一下这个题目，用的是一个思路解题，这个思路我称之为“借刀杀人”。

很容易想到的就是贪心做法，易知叶子结点没有人给他染色，所以他只能自己给自己染，然后染过色的节点我们就用一个vis数组标记一下，就不用再染色了，一直往上走找没有染过色的节点。

这个思路有一点点小问题，就是假如一个节点他的子节点了，这个节点的父节点假设还有1000，并且他的k为1000，其父节点的k全都是1。这个时候你说是选它还是不选它？

所以刚才那种贪心行不通的，这时候就想想，我要在什么情况下判断当前这个点要不要自己给自己染色呢，那么染色之后怎么维护k呢

当前节点为 u，儿子节点为 v。k[u] = max(k[u], k[v]-1) 这个式子，儿子节点减1应该好理解，因为他的深度多一级嘛，向上染色也就比u节点本身少一个位置。这样只是保证了

当前节点为u， 儿子节点为v，我们怎么判定这个点要不要自己染色呢，是不是没有子节点可以给他染色的时候就需要自己动手了，那么如何知道子节点有没有能力呢，需要引进一个son数组，开始初始化为0，递归到叶子结点的时候发现没有子节点给自己染色，那么son的值就等于这个节点的k，然后一直维护下去, son[u] = max(son[u], son[v]-1)。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, k[100005], son[100005], ans;
vector <int> g[100005];

void dfs(int x) {
	for(int i = 0;i < g[x].size(); i++) {
		int u = g[x][i];
		dfs(u);
		k[x] = max(k[x], k[u]-1);
		son[x] = max(son[x], son[u]-1);
	}
	if(son[x] == 0) {
		ans++;
		son[x] = k[x];
	}
}

int main() {
	scanf("%d", &n);
	int fa;
	for(int i = 2;i <= n; i++) {
		scanf("%d", &fa);
		g[fa].push_back(i);
	}
	for(int i = 1;i <= n; i++) scanf("%d", &k[i]);
	
	dfs(1);
	printf("%d\n", ans);
}
```