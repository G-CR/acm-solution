## 语言

### 指针和引用的区别

1、指针有自己的一块空间，而引用只是一个别名

2、使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小

3、指针可以被初始化为NULL，而引用必须被初始化为一个已有的对象的大小

4、作为参数传递时，指针需要被引用才可以对对象进行操作，而对引用的修改都会改变引用所指向的对象

5、可以有const指针，但是没有const引用

6、指针在使用中可以只想其他对象，但是引用只能是一个对象的引用，不能被改变

7、指针可以有多级指针(**p)，而引用只有一级

8、指针和引用使用++运算的意义不一样

9、如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏



### 常用的容器,它们底层的数据结构

1、vector：数组，支持快速随机访问

2、list：双向链表

2、map：红黑树，有序不重复

3、set ：红黑树，有序不重复

4、stack：list或deque，不用vector的原因是因为容量有大小，扩容耗时

5、queue：list或deque，不用vector的原因是因为容量有大小，扩容耗时

6、pair

7、string

### map与set的区别

1、map：key-value，而set是关键字的简单集合

2、set的迭代器是const的，不允许修改元素的值；map只允许修改value的值（如果可以修改会导致之前的iterator失效，因为修改是基于删除后重新插入来的，所以不清楚iterator指向之前的位置还是新位置）

3、map支持下标操作，set不支持



### vector 和 list 的区别

**vector**

连续存储的容器，动态数组，在堆上分配空间

底层实现：数组

两倍容量增长

vector增加新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后，然后调整迭代器

如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化空间，再向新空间添加新元素，最后释放原空间，之前的迭代器会失效。

性能：

访问：O（1）

插入：在最后插入（空间够）：很快

​			在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝

​			在中间插入（空间够）：内存拷贝

​			在中间插入（内存不够）：需要内存申请和释放，以及对之前数据进行拷贝

删除：在最后删除：很快

​			在中间删除：内存拷贝

使用场景：经常随机访问，且不经常对非尾节点进行插入删除



**list**

动态链表，在堆上分配空间，每插入一个元素都会分配空间，每删除一个元素都会释放空间。

底层：双向链表

性能：

访问：随机访问性能很差，只能快速访问头尾节点

插入：很快，常数开销

删除：很快，常数开销

使用场景：经常插入删除大量数据



**区别**

1、vector底层是数组，list是双向链表

2、vector支持随机访问，list不支持

3、vector是顺序内存，list不是

4、vector在中间节点进行插入删除的时候会进行内存拷贝，list不会

5、vector一次性分配好内存，不够时才进行2倍扩容，list每次插入新节点都会进行内存申请

6、vector随机访问性能很好，插入删除性能很差，list随机访问性能差，插入删除性能好。



### 介绍一下STL的allocator

STL的分配器用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：

new运算分为两个阶段：

1、调用::operator new 配置内存

2、调用对象构造函数构造对象内容

delete运算分为两个阶段：

1、调用对象析构函数

2、调用::operator delete释放内存为了精密分工，STL allocator 将两个步骤区分开来：内存配置有alloc::allocate()负责，内存释放由alloc::deadllocate()负责；对象构造由::construct负责，对象析构由::destroy负责

同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGISTL采用了两级分配器，当分配空间大于128B的时，会使用**第一级空间配置器**；当分配空间小于128B时，将使用**第二级空间配置器**。第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。

### 智能指针

智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。C++11中最常用的智能指针类型为shared_ptr，它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数+1，当过期时引用计数-1。只有引用计数为0时，智能指针才会自动释放引用的内存资源。对shared_ptr进行初始化时不能将一个普通指针直接赋给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针，并且可以通过get函数获得普通指针。

### 静态库

1、静态库对函数库的链接时放在编译时期完成的

2、程序在运行时与函数库再无瓜葛，移植方便

3、浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件

### 动态库

1、动态库把对一些库函数的链接载入推迟到程序运行时期

2、可以实现进程之间的资源共享。（因此动态库也称为共享库）

3、将一些程序升级变得简单

4、甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）

### malloc 与 new

malloc 需要给定申请内存大小，返回的指针需要强制转换

new 会调用构造函数，不用指定内存大小，返回的指针不用强制转换

### 多态

多态分为编译时多态和运行时多态：

1、**编译时多态**主要指方法的重载

2、**运行时多态**指程序中定义的对象引用所指向的具体数据类型在运行期间才确定

运行时多态有**三个条件**：

继承

覆盖（重写）

向上转型

### 纯虚函数

纯虚函数是基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 "=0"

## 操作系统

### 操作系统的分页和分段

**分页：**为了更好的管理内存，操作系统将内存抽象成地址空间，每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块成为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序应用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的命令。

**分段：**分段是把每个表分成段，一个段构成一个独立的空间。每个段的长度可以不同，并且可以动态增长。

**段页式：**程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

**区别：**

对程序员的透明性：分页透明；但是分段需要程序员显示划分每个段

地址空间的维度：分页是一维地址空间，分段是二维的

大小是否可以改变：页的大小不可变，段的大小可以动态改变

出现的原因：分页主要用于一维地址空间，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

### 自旋锁

**概念：**线程获取锁的时候，如果锁被其他线程持有，则当前线程将循环等待，直到获取到锁。

**特点：**

1、自旋锁等待期间，线程的状态不会发生改变，线程一直是用户态并且是活动的。

2、自旋锁如果持有锁的时间太长，则会导致其他等待获取锁的线程耗尽CPU

3、自旋锁自身无法保证公平性，同时也无法保证重入性。

4、基于自旋锁可以实现具备公平性和可重入性的锁。

### 进程、线程、协程，进程间通信的方式

**进程：** 操作系统会以进程为单位，分配系统资源（CPU时间片、内存），进程是资源分配的最小单位。

**进程间通信：**

1、管道

2、命名管道 

3、消息队列 

4、信号量 

5、共享内存 

6、套接字

**线程：**操作系统调度（CPU调度）执行的最小单位。

**进程与线程的**

**区别：**

1、调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位

2、并发性：进程之间可以并发执行，同一进程的多个线程之间也可以并发执行

3、拥有资源：进程食用油资源的独立单位，线程不拥有系统资源

4、系统开销：由于进程拥有独立空间，而线程只是进程中的不同执行路径，所以多进程的程序要比多线程的程序健壮；但是由于创建和撤销进程表都需要分配和回收资源，所以进程耗费资源较大，效率较低。

**联系：**

1、一个线程只能属于一个进程，而一个进程可以拥有多个线程。

2、资源分配给进程，同一进程的所有线程共享该进程的所有资源

3、处理机分给线程，即真正在处理机上运行的是线程

4、线程在执行过程中，需要协作同步。不同的进程间要利用消息通信的办法实现同步

**协程：**

是一种比线程**更轻量级**的存在，协程不是被操作系统管理，而完全是由程序所控制（在**用户态执行**）。这样带来的好处就是**性能**得到了很大的提升，不会像线程切换那样**消耗资源**。



### 生产者消费者

### 虚拟内存

### 锁



## 计算机网络

### TCP和UDP的区别

1、TCP面向连接；UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠的交付。TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发机制，还可以对次序乱掉的分包进行顺序控制。

3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或者广播通信。

4、每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。

5、TCP对系统资源要求较多，UDP对系统资源要求较少

6、若通信数据完整性需让位与通信实时性，则应该选用TCP协议（文件传输、重要的状态更新）；反之，则使用UDP协议（视频传输、实施通信）

7、UDP：DNS SNMP

8、TCP面向字节流 ，UDP面向数据包

### IO多路复用哪些方式

select / poll / epoll



### tcp三次握手

1、client将SYN设置为1，并且随机生成了一个值seq = j，然后把这个数据包发给server，此时client的状态变为SYN_SENT

2、sever收到数据包后，检查SYN的值是否为1，如果正确就将SYN的值设置为1，并且随机生成一个seq = k，并且将ack的值设置为j+1，把ACK的值设置为1，并且随机生成一个seq = k，把ACK的值设置为1，然后将此数据包发给cilent，server的状态变为SYN_RCVD

3、client收到数据包后检查ACK的值是否为1，ack的值是否为j+1，SYN的值是否为1，如果正确就将ACK的值也设置为1，将ack的值设置为k+1，然后把该数据包发送给server，server接收到数据包后检查ack的值是否为k+1，ACK的值是否为1，如果正确，client与server的状态都改为ESTABLISHED，然后双方可以开始发送数据了。

### TCP为什么是四次挥手

由于TCP是全双工通信，所以在关闭连接的时候是需要两边分别关闭的，所以在当一边发出FIN的报文段时，只是单方面关闭了发送数据的通道，而另一边仍然可以发送数据，直到另一边也发出了FIN的报文段时，才意味着连接断开。

1、客户端向服务端发送FIN的释放信号，此时客户端向服务端发送数据的通道关闭，状态变为FIN_WAIT_1

2、服务端收到客户端的FIN信号后，反馈一个ACK=1的确认应答，确认序列号为收到的序号+1，客户端进入FIN_WAIT_2状态，服务端进入CLOSE_WAIT状态

3、当服务端没有数据发送时，向客户端发送一个FIN信号，等待客户端确认，服务端进入LAST_ACK状态

4、客户端收到FIN信号后，向服务器发送一个ACK报文，确认序列号为收到的序号+1，此时客户端状态变为TIME_WAIT状态，等待2MSL，然后关闭连接。

### ARP协议

arp协议是一种解析协议，本来主机时完全不知道这个IP对应的是哪个主机的接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存表（最近数据传递更新的IP-MAC地址对应表），如果查询的IP-MAC值对不存在，那么主机就向网络广播一个arp请求包，这个包里就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到的广播包的某一个主机发现自己符合条件，那么就回应一个应答包（将自己对应的IP-MAC对应地址发回主机），源主机根据新的arp缓存表准备好数据链路层的数据包发送工作。

### osi七层模型



### TCP为什么稳定

**1、序列号、确认应答、超时重传**

数据达到接收方，接收方需要发出一个确认应答，表示已经接收到的该数据段，并且确认序列号会说明下一次需要接受的数据序列号。如果发送迟迟未收到确认应答，那么可能是发送的数据丢失，也可能确认应答丢失，这时发送方在等待一段时间会进行重传，这个时间一般是 2*rtt+一个偏差值。

**2、窗口控制、快速重传**

tcp会利用窗口控制来提高传输速度，意思就是在一个窗口大小内，不用一定要等到应答才能下一段数据，窗口大小就是无需等待而可以继续发送数据的最大值，如果不适应窗口控制，每一个没确认应答的数据都要重发。

使用窗口控制，就是数据段1001～2000丢失，后面的数据每次传输，确认应答都会不停的发送序号为1001的应答，表示我要接受1001开始的数据了，发送端如果接收到3次相同的回答，就会立刻进行重发；但还有一种情况收到了，但是有的应答丢失了，这种情况就不会重发，因为发送端知道，如果是数据丢失，接受端不会放过它的，就会疯狂提醒。

**3、拥塞控制**

如果窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵，甚至网络的瘫痪，所以tcp为了防止这种情况的发生而进行了拥塞控制。

**（1）慢启动：** 定义拥塞窗口，一开始将窗口大小设置为1，之后每次收到的确认应答，将拥塞窗口大小乘以2

**（2）拥塞避免：** 设置慢启动阈值，一般开始为65336，拥塞避免实质当窗口大小到阈值的时候，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口+1），以此来避免拥塞。

**（3）快速重传：** 在遇到三次重复的确认应答时，代表收到了3个报文段，但是这之前的1个段丢失了，以便对它进行立即重传。然后，先将阈值设置为当前窗口大小的一半，然后再将窗口大小设置为慢启动阈值+3的大小。这样可以达到：TCP通信时网络吞吐量呈现逐渐上升，并且随着拥堵来降低吞吐量，再慢慢上升的过程，网络不易瘫痪。

### http 和 https 的区别

1、http传输是以明文的方式进行传输的，https是经过TLS加密后传输的，具有更高的安全性

2、https在tcp的三次握手之后，还需要进行SSL的handshake过程，协商加密使用的是对称加密密钥

3、https需要服务端申请证书，浏览器安装对应的根证书

4、http协议端口时80，https的协议端口时443
