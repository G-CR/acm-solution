## 语言

#### 四种常见的线程池

**1、定长线程池**

一个有指定的线程数的线程池，有核心线程池，里面有固定的线程数量，响应速度快。正规的并发线程，多用于服务器。固定的线程数由系统资源设置。核心线程是没有超时机制的，队列大小没有限制，除非线程池关闭了核心线程才会被回收。

**2、可缓冲线程池**

只有非核心线程，最大线程数很大，每来一个新任务，当没有空余线程的时候就会重新创建一个线程，这边有一个超时机制，当空闲的线程超过60s没有用到的话就会被回收，它可以一定程度减少频繁创建/销毁线程，减少系统开销，适用于执行时间短并且数量多的任务场景。

**3、周期线程池**

创建一个定长线线程池，支持定时及周期性任务执行，通过schedule方法可以设置任务的周期执行

**4、单任务线程池**

创建一个单线程化的线程池，他只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO, LIFO, 优先级）执行，每次任务到来后都会进入阻塞队列，然后按指定顺序执行



#### 指针和引用的区别

1、指针有自己的一块空间，而引用只是一个别名

2、使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小

3、指针可以被初始化为NULL，而引用必须被初始化为一个已有的对象的大小

4、作为参数传递时，指针需要被引用才可以对对象进行操作，而对引用的修改都会改变引用所指向的对象

5、可以有const指针，但是没有const引用

6、指针在使用中可以只想其他对象，但是引用只能是一个对象的引用，不能被改变

7、指针可以有多级指针(**p)，而引用只有一级

8、指针和引用使用++运算的意义不一样

9、如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏



### 常用的容器,它们底层的数据结构 

1、vector：数组，支持快速随机访问

2、list：双向链表

2、map：红黑树，有序不重复

3、set ：红黑树，有序不重复

4、stack：list或deque，不用vector的原因是因为容量有大小，扩容耗时

5、queue：list或deque，不用vector的原因是因为容量有大小，扩容耗时

6、pair

7、string

### map与set的区别

1、map：key-value，而set是关键字的简单集合

2、set的迭代器是const的，不允许修改元素的值；map只允许修改value的值（如果可以修改会导致之前的iterator失效，因为修改是基于删除后重新插入来的，所以不清楚iterator指向之前的位置还是新位置）

3、map支持下标操作，set不支持



### vector 和 list 的区别

**vector**

连续存储的容器，动态数组，在堆上分配空间

底层实现：数组

两倍容量增长

vector增加新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后，然后调整迭代器

如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化空间，再向新空间添加新元素，最后释放原空间，之前的迭代器会失效。

性能：

访问：O（1）

插入：在最后插入（空间够）：很快

​			在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝

​			在中间插入（空间够）：内存拷贝

​			在中间插入（内存不够）：需要内存申请和释放，以及对之前数据进行拷贝

删除：在最后删除：很快

​			在中间删除：内存拷贝

使用场景：经常随机访问，且不经常对非尾节点进行插入删除



**list**

动态链表，在堆上分配空间，每插入一个元素都会分配空间，每删除一个元素都会释放空间。

底层：双向链表

性能：

访问：随机访问性能很差，只能快速访问头尾节点

插入：很快，常数开销

删除：很快，常数开销

使用场景：经常插入删除大量数据



**区别**

1、vector底层是数组，list是双向链表

2、vector支持随机访问，list不支持

3、vector是顺序内存，list不是

4、vector在中间节点进行插入删除的时候会进行内存拷贝，list不会

5、vector一次性分配好内存，不够时才进行2倍扩容，list每次插入新节点都会进行内存申请

6、vector随机访问性能很好，插入删除性能很差，list随机访问性能差，插入删除性能好。

### 介绍一下STL的allocator





