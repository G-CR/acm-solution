### 基本东西

```cpp
const double PI = acos(-1.0);
const double eps = 1e-8;

int sgn(double x) {
	if(fabs(x) < eps) return 0;
	if(x < 0) return -1;
	else return 1;
}

// 表示点
struct Point {
	double x, y;
	Point(){}
	Point(double _x,double _y) {
		x = _x; y = _y;
	}
	Point operator + (const Point& b) const {
		return Point(x + b.x,y + b.y);
	}
	Point operator - (const Point &b) const {
		return Point(x - b.x,y - b.y);
	}
	double operator * (const Point &b) const {
		return x*b.x + y*b.y;
	}
	double operator ^ (const Point &b) const {
		return x*b.y - y*b.x;
	}
	bool operator < (Point b) const {
		return sgn(x-b.x) == 0 ? sgn(y-b.y) < 0: x < b.x;
	}
	bool operator == (Point b) const {
		return sgn(x-b.x) == 0 && sgn(y-b.y) == 0;
	}
};

// 表示线段
struct Line {
	Point s,e;
	Line(){}
	Line(Point _s,Point _e) {
		s = _s;e = _e;
	}
	
	// 判断直线相交的，无需要可以不用（如果相交返回交点的版本，下面有一个只做判断的版本）
	// 返回pair second为0重合 为1平行 为2相交且first为交点
	pair <int, Point> operator &(const Line &b)const { 
		Point res = s;
		if(sgn((s-e)^(b.s-b.e)) == 0) {
			if(sgn((b.s-s)^(b.e-s)) == 0)
				return make_pair(0,res);//两直线重合
			else return make_pair(1,res);//两直线平行
		}
		double t = ((s-b.s)^(b.s-b.e))/((s-e)^(b.s-b.e));
		res.x += (e.x - s.x)*t;
		res.y += (e.y - s.y)*t;
		return make_pair(2,res);//有交点
	}
	
	
	//线段与线段相交判断
	//2 规范相交
	//1 非规范相交
	//0 不相交
	int seg_cross_seg(Line v){
		int d1 = sgn((e-s)^(v.s-s));
		int d2 = sgn((e-s)^(v.e-s));
		int d3 = sgn((v.e-v.s)^(s-v.s));
		int d4 = sgn((v.e-v.s)^(e-v.s));
		if((d1^d2)==-2&&(d3^d4)==-2) return 2;
		return (d1==0 &&sgn((v.s-s)*(v.s-e))<=0)||
		(d2==0 &&sgn((v.e-s)*(v.e-e))<=0)||
		(d3==0 &&sgn((s-v.s)*(s-v.e))<=0)||
		(d4==0 &&sgn((e-v.s)*(e-v.e))<=0);
	}
	
	int relation(Point p){
		int c=sgn((p-s)^(p-e));
		if(c<0)return 1;
		else if(c>0) return 2;
		else return 3;
	}
	bool parallel(Line v){
		return sgn((e-s)^(v.e-v.s))==0;
	}
	//直线与直线相交判断
	//0 平行
	//1 重合
	//2 相交
	int line_cross_line(Line v){
		if((*this).parallel(v))
			return v.relation(s)==3;
		return 2;
	}
};
```



### 点线相关

```cpp
//两点距离
double dist(Point a,Point b) {
	return sqrt((b-a)*(b-a));
}

// 三个点计算叉积 p0p1 ^ p0p2
double xmult(Point p0,Point p1,Point p2) { 
	return (p1-p0)^(p2-p0);
}

//*判断线段相交
bool inter(Line l1,Line l2) {
	return
	max(l1.s.x,l1.e.x) >= min(l2.s.x,l2.e.x) &&
	max(l2.s.x,l2.e.x) >= min(l1.s.x,l1.e.x) &&
	max(l1.s.y,l1.e.y) >= min(l2.s.y,l2.e.y) &&
	max(l2.s.y,l2.e.y) >= min(l1.s.y,l1.e.y) &&
	sgn((l2.s-l1.e)^(l1.s-l1.e))*sgn((l2.e-l1.e)^(l1.s-l1.e)) <= 0 &&
	sgn((l1.s-l2.e)^(l2.s-l2.e))*sgn((l1.e-l2.e)^(l2.s-l2.e)) <= 0;
}

// 判断直线l1和线段l2是否相交
bool Seg_inter_line(Line l1, Line l2) { 
	return sgn(xmult(l2.s,l1.s,l1.e))*sgn(xmult(l2.e,l1.s,l1.e)) <= 0;
}

// 点P在直线AB上的投影
Point GetLineProjection(Point P,Point A,Point B) {
	Point v = B - A;
	double t = (v * (P-A)) / (v*v);
	return A + Point(v.x*t, v.y*t);
}

//点到线段的距离
//返回点到线段最近的点
Point NearestPointToLineSeg(Point P,Line L) {
	Point result;
	double t = ((P-L.s)*(L.e-L.s))/((L.e-L.s)*(L.e-L.s));
	if(t >= 0 && t <= 1) {
		result.x = L.s.x + (L.e.x - L.s.x)*t;
		result.y = L.s.y + (L.e.y - L.s.y)*t;
	}
	else {
		if(dist(P,L.s) < dist(P,L.e))
			result = L.s;
		else result = L.e;
	}
	return result;
}

//*判断点在线段上
bool OnSeg(Point P,Line L) {
	return
	sgn((L.s-P)^(L.e-P)) == 0 &&
	sgn((P.x - L.s.x) * (P.x - L.e.x)) <= 0 &&
	sgn((P.y - L.s.y) * (P.y - L.e.y)) <= 0;
}

// 三点共圆圆心公式
Point center(Point a, Point b, Point c) {
	double X, Y;
	double fm1=2 * (a.y - c.y) * (a.x - b.x) - 2 * (a.y - b.y) * (a.x - c.x);
	double fm2=2 * (a.y - b.y) * (a.x - c.x) - 2 * (a.y - c.y) * (a.x - b.x);
	if (fm1 == 0 || fm2 == 0) {
		X = Y = 1e18;
		return Point(X, Y);
	}
	double fz1=a.x * a.x - b.x * b.x + a.y * a.y - b.y * b.y;
	double fz2=a.x * a.x - c.x * c.x + a.y * a.y - c.y * c.y;
	X = (fz1 * (a.y - c.y) - fz2 * (a.y - b.y)) / fm1;
	Y = (fz1 * (a.x - c.x) - fz2 * (a.x - b.x)) / fm2;
	
	return Point(X, Y);
}
```



### 凸边形相关

```cpp
const int N = 1003;
Point poly[N];
int sta[N], top;

//利用极角排序，角度相同则距离小排前面
bool cmp(Point p1, Point p2) {
	double tmp = xmult(poly[0], p1, p2);
	if (tmp > 0)
		return true;
	else if (tmp == 0 && dist(poly[0], p1) < dist(poly[0], p2))
		return true;
	else
		return false;
}

//输入，并把  最左下方的点放在 poly[0] , 并且进行极角排序
void init(int n) {
	int i, k = 0;
	cin >> poly[0].x >> poly[0].y;
	Point p0 = poly[0];  // p0 等价于 tmp 去寻找最左下方的点
	for (int i = 1; i < n; ++i) {
		cin >> poly[i].x >> poly[i].y;
		if (p0.y > poly[i].y || (p0.y == poly[i].y && p0.x > poly[i].x))
			p0 = poly[i], k = i;
	}
	poly[k] = poly[0];
	poly[0] = p0;
	sort(poly + 1, poly + n, cmp);
}

//graham扫描法求凸包，凸包顶点存在sta栈中
//从栈底到栈顶一次是逆时针方向排列的
//如果要求凸包的一条边有2个以上的点
//那么要将while中的<=改成<
//但这不能将最后一条边上的多个点保留
//因为排序时将距离近的点排在前面
//那么最后一条边上的点仅有距离最远的会被保留，其余的会被出栈
//所以最后一条边需要特判
//如果要求逆凸包的话需要改cmp，graham中的符号即可
void Graham(int n) {
	if (n == 1) top = 0, sta[0] = 0;
	if (n == 2) top = 1, sta[0] = 0, sta[1] = 1;
	if (n > 2) {
		for (int i = 0; i <= 1; i++) sta[i] = i;
		top = 1;
		
		for (int i = 2; i < n; i++) {
			while (top > 0 && xmult(poly[sta[top - 1]], poly[sta[top]], poly[i]) <= 0)
				top--;
			top++;
			sta[top] = i;
		}
	}
}

//判断凸多边形
//允许共线边
//点可以是顺时针给出也可以是逆时针给出
//点的编号1~n-1
bool isconvex(Point poly[],int n) {
	bool s[3];
	memset(s,false,sizeof(s));
	for(int i = 0;i < n;i++) {
		s[sgn( (poly[(i+1)%n]-poly[i])^(poly[(i+2)%n]-poly[i]) )+1] = true;
		if(s[0] && s[2])return false;
	}
	return true;
}

//*判断点在凸多边形内
//点形成一个凸包，而且按逆时针排序（如果是顺时针把里面的<0改为>0）
//点的编号:0~n-1
//返回值：
//-1:点在凸多边形外
//0:点在凸多边形边界上
//1:点在凸多边形内
int inConvexPoly(Point a,Point p[],int n) {
	for(int i = 0;i < n;i++) {
		if(sgn((p[i]-a)^(p[(i+1)%n]-a)) < 0)return -1;
		else if(OnSeg(a,Line(p[i],p[(i+1)%n])))return 0;
	}
	return 1;
}

//*判断点在任意多边形内
//射线法，poly[]的顶点数要大于等于3,点的编号0~n-1
//返回值
//-1:点在凸多边形外
//0:点在凸多边形边界上
//1:点在凸多边形内
int inPoly(Point p,Point poly[],int n) {
	int cnt;
	Line ray,side;
	cnt = 0;
	ray.s = p;
	ray.e.y = p.y;
	ray.e.x = -100000000000.0;//-INF,注意取值防止越界

	for(int i = 0;i < n;i++) {
		side.s = poly[i];
		side.e = poly[(i+1)%n];

		if(OnSeg(p,side))return 0;

		//如果平行轴则不考虑
		if(sgn(side.s.y - side.e.y) == 0)
			continue;

		if(OnSeg(side.s,ray)) {
			if(sgn(side.s.y - side.e.y) > 0)cnt++;
		}
		else if(OnSeg(side.e,ray)) {
			if(sgn(side.e.y - side.s.y) > 0)cnt++;
		}
		else if(inter(ray,side)) cnt++;
	}
	if(cnt % 2 == 1) return 1;
	else return -1;
}



```



### 三角形相关

```cpp

// 三角形求垂心、重心、内心、外心
//重心：三条中线的交点
Point centroid(Point A, Point B, Point C) {
	Point res = A + B + C;
	return Point(res.x/3, res.y/3);
}

//内切圆圆心
Point incenter(Point A, Point B, Point C) {
	double a = dist(B, C);
	double b = dist(A, C);
	double c = dist(A, B);
	double S = a + b + c;
	double x = (a * A.x + b * B.x + c * C.x) / S;
	double y = (a * A.y + b * B.y + c * C.y) / S;
	return Point(x, y);
}

//外接圆圆心
Point circumcenter(Point A, Point B, Point C) {
	double x1 = A.x, y11 = A.y;
	double x2 = B.x, y2 = B.y;
	double x3 = C.x, y3 = C.y;
	
	double a1 = 2 * (x2 - x1);
	double b1 = 2 * (y2 - y11);
	double c1 = x2*x2 + y2*y2 - x1*x1 - y11*y11;
	
	double a2 = 2 * (x3-x2);
	double b2 = 2 * (y3-y2);
	double c2 = x3*x3 + y3*y3 - x2*x2 - y2*y2;
	
	double x = (c1*b2 - c2*b1) / (a1*b2 - a2*b1);
	double y = (a1*c2 - a2*c1) / (a1*b2 - a2*b1);
	
	return Point(x,y);
}

// 垂心：三边垂直平分线的交点
Point orthocenter(Point A, Point B, Point C) {
	Point cent = centroid(A, B, C);
	cent = Point(cent.x * 3.0, cent.y * 3);
	
	Point circ = circumcenter(A, B, C);
	circ = Point(circ.x * 2.0, circ.y * 2.0);
	return cent - circ;
}


```

